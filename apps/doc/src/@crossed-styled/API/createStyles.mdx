# Building Styles with `createStyles`

Before diving into how to use `createStyles`, it’s important to understand how to define and organize your styles. Below are several examples showing how to structure styles effectively in a React application.

## Example: Defining Text Styles

The following code demonstrates how to define styles for various text states: default, disabled, primary, secondary, and tertiary.

```tsx
import { createStyles } from "@crossed/styled";

export const textStyles = createStyles((t) => ({
  default: {
    base: { fontWeight: 'bold' },
  },
  disabled: { base: { pointerEvents: 'none' } },
  primary: {
    'base': { color: t.components.Action.primary.default.text },
    ':hover': { color: t.components.Action.primary.hover.text },
    ':active': { color: t.components.Action.primary.active.text },
  },
  secondary: {
    'base': { color: t.components.Action.secondary.default.text },
    ':hover': { color: t.components.Action.secondary.hover.text },
    ':active': { color: t.components.Action.secondary.active.text },
  },
  tertiary: {
    'base': { color: t.components.Action.tertiary.default.text },
    ':hover': { color: t.components.Action.tertiary.hover.text },
    ':active': { color: t.components.Action.tertiary.active.text },
  },
  false: {},
}));
```

### Explanation

- **base**: Each style group has a `base` property that holds the base styles. For example, the default text is bold (`fontWeight: 'bold'`).
- **dynamic states**: You can also define styles for different states (`:hover`, `:active`, etc.). In this example, the styles change based on the user's interaction.
- **theme (`t`)**: `t` represents the global theme, which allows you to access pre-defined colors and other theme variables for consistency across your app.

---

## Handling Disabled Styles

It’s often useful to define specific styles for disabled elements, as shown in this example.

```tsx
export const textDisabledStyles = createStyles((t) => ({
  primary: {
    base: { color: t.components.Action.primary.disabled.text },
  },
  secondary: {
    base: { color: t.components.Action.secondary.disabled.text },
  },
  tertiary: {
    base: { color: t.components.Action.tertiary.disabled.text, opacity: 0.5 },
  },
  false: {},
}));
```

### Explanation

- **Disabled colors**: Here, each style is associated with a specific color for disabled states (`disabled.text`) from the global theme. The `opacity` property is also used to adjust transparency for disabled elements.

---

## Error Styles

When an error occurs, you can also customize the styles of affected elements.

```tsx
const textErrorStyles = createStyles((t) => ({
  primary: {
    base: { color: 'white' },
  },
  secondary: {
    'base': { color: t.colors.error.primary },
    ':hover': { color: t.colors.error.muted },
    ':active': { color: t.colors.error.satured },
    ':disabled': { color: t.colors.error.hight },
  },
  tertiary: {
    'base': { color: t.colors.error.primary },
    ':hover': { color: t.colors.error.muted },
    ':active': { color: t.colors.error.satured },
    ':disabled': { color: t.colors.error.hight },
  },
}));
```

### Explanation

- **Error colors**: These styles handle different interaction states (hover, active, disabled) when the component is in an error state. These colors are defined from the theme’s error palette.

---

## Text Alignment

Finally, here’s how to handle text alignment using `createStyles`:

```tsx
export const textAlignStyles = createStyles(() => ({
  auto: { base: { textAlign: 'auto' } },
  justify: { base: { textAlign: 'justify' } },
  default: { base: { textAlign: 'left' } },
  center: { base: { textAlign: 'center' } },
  left: { base: { textAlign: 'left' } },
  right: { base: { textAlign: 'right' } },
}));
```

### Explanation

- **Alignment properties**: These styles make it easy to manage text alignment (`textAlign`) with values like `center`, `left`, `right`, etc. This allows you to adjust the visual context of text effectively.

---

## Conclusion

These examples show how to build flexible and dynamic styles using `createStyles`. You can easily customize them for different interaction states, error handling, or visual contexts while keeping a modular and maintainable approach.