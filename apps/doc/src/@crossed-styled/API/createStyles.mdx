# Building Styles with `createStyles`

Before diving into how to use `createStyles`, it’s important to understand how to define and organize your styles. Below are several examples showing how to structure styles effectively in a React application.

## Example: Defining Text Styles

The following code demonstrates how to define styles for various text states: default, disabled, primary, secondary, and tertiary.

```tsx
import { createStyles } from "@crossed/styled";

export const textStyles = createStyles(({ colors }) => ({
  primary: { base: { color: colors.text.primary.default } },
  secondary: { base: { color: colors.text.secondary.default } },
  tertiary: { base: { color: colors.text.tertiary.default } },
  quaternary: { base: { color: colors.text.quaternary.default } },
  warning: { base: { color: colors.text.warning.default } },
  error: { base: { color: colors.text.error.default } },
  success: { base: { color: colors.text.success.default } },
  brand: { base: { color: colors.text.brand.primary.default } },
  primaryBrand: { base: { color: colors.text.primary.brand } },
  tertiaryBrand: { base: { color: colors.text.tertiary.brand } },
}));
```

### Explanation

- **base**: Each style group has a `base` property that holds the base styles. For example, the default text is bold (`fontWeight: 'bold'`).
- **dynamic states**: You can also define styles for different states (`:hover`, `:active`, etc.). In this example, the styles change based on the user's interaction.
- **theme (`t`)**: `t` represents the global theme, which allows you to access pre-defined colors and other theme variables for consistency across your app.

---

## Handling Disabled Styles

It’s often useful to define specific styles for disabled elements, as shown in this example.

```tsx
export const textDisabledStyles = createStyles(({ colors }) => ({
  primary: {
    base: { color: colors.text.primary.default },
  },
  secondary: {
    base: { color: colors.text.secondary.default },
  },
  tertiary: {
    base: { color: colors.text.tertiary.default, opacity: 0.5 },
  },
}));
```

### Explanation

- **Disabled colors**: Here, each style is associated with a specific color for disabled states (`disabled.text`) from the global theme. The `opacity` property is also used to adjust transparency for disabled elements.

---

## Error Styles

When an error occurs, you can also customize the styles of affected elements.

```tsx
const textErrorStyles = createStyles(({ colors }) => ({
  primary: {
    base: { color: 'white' },
  },
  secondary: {
    'base': { color: colors.text.primary.default },
    ':hover': { color: colors.text.secondary.default },
    ':active': { color: colors.text.tertiary.default },
    ':disabled': { color: colors.text.disabled.hight },
  },
}));
```

### Explanation

- **Error colors**: These styles handle different interaction states (hover, active, disabled) when the component is in an error state. These colors are defined from the theme’s error palette.

---

## Text Alignment

Finally, here’s how to handle text alignment using `createStyles`:

```tsx
export const textAlignStyles = createStyles(() => ({
  auto: { base: { textAlign: 'auto' } },
  justify: { base: { textAlign: 'justify' } },
  default: { base: { textAlign: 'left' } },
  center: { base: { textAlign: 'center' } },
  left: { base: { textAlign: 'left' } },
  right: { base: { textAlign: 'right' } },
}));
```

### Explanation

- **Alignment properties**: These styles make it easy to manage text alignment (`textAlign`) with values like `center`, `left`, `right`, etc. This allows you to adjust the visual context of text effectively.

---

## Conclusion

These examples show how to build flexible and dynamic styles using `createStyles`. You can easily customize them for different interaction states, error handling, or visual contexts while keeping a modular and maintainable approach.
